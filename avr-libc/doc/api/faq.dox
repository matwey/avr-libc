/* Copyright (c) 2002, Joerg Wunsch
   All rights reserved.

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions are met:

   * Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE. */

/* $Id$ */

/** \page FAQ Frequently Asked Questions

<b>\subsection faq_index FAQ Index
</b>

\addindex FAQ

-# \ref faq_volatile
-# \ref faq_libm
-# \ref faq_regbind
-# \ref faq_startup
-# \ref faq_use_bv
-# \ref faq_cplusplus
-# \ref faq_16bitio
-# \ref faq_asmconst

<b>\subsection faq_volatile My program doesn't recognize a variable updated within an interrupt routine
</b>

When using the optimizer, in a loop like the following one:

\code
uint8_t flag;
...

	while (flag == 0) {
		...
	}
\endcode

the compiler will typically optimize the access to \c flag completely
away, since its code path analysis shows that nothing inside the loop
could change the value of \c flag anyway.  To tell the compiler that
this variable could be changed outside the scope of its code path
analysis (e. g. from within an interrupt routine), the variable needs
to be declared like:

\code
volatile uint8_t flag;
\endcode

<small>Back to \ref faq_index.
</small>

<b>\subsection faq_libm I get "undefined reference to..." for functions like "sin()"
</b>

In order to access the mathematical functions that are declared in
<tt>\<math.h\></tt>, the linker needs to be told to also link the
mathematical library, <tt>libm.a</tt>.

Typically, system libraries like <tt>libm.a</tt> are given to the
final C compiler command line that performs the linking step by adding
a flag <tt>-lm</tt> at the end.  (That is, the initial \a lib and the
filename suffix from the library are written immediately after a \a -l
flag.  So for a <tt>libfoo.a</tt> library, <tt>-lfoo</tt> needs to be
provided.)  This will make the linker search the library in a path
known to the system.

An alternative would be to specify the full path to the
<tt>libm.a</tt> file at the same place on the command line, i. e. \a
after all the object files (<tt>*.o</tt>).  However, since this
requires knowledge of where the build system will exactly find those
library files, this is deprecated for system libraries.

<small>Back to \ref faq_index.
</small>

<b>\subsection faq_regbind How to permanently bind a variable to a register?
</b>

This can be done with

\code
register unsigned char counter asm("r3");
\endcode

See \ref c_names_in_asm for more details.

<small>Back to \ref faq_index.
</small>

<b>\subsection faq_startup How to modify MCUCR or WDTCR early?
</b>

The method of early initialization (<tt>MCUCR</tt>, <tt>WDTCR</tt> or
anything else) is different (and more flexible) in the current
version.  Basically, write a small assembler file which looks like
this:

\code
;; begin xram.S

#include <avr/io.h>

        .section .init1,"ax",@progbits

        ldi r16,_BV(SRE) | _BV(SRW)
        out _SFR_IO_ADDR(MCUCR),r16

;; end xram.S
\endcode

Assemble it, link the resulting <tt>xram.o</tt> with other files in
your program, and this piece of code will be inserted in
initialization code, which is run right after reset.  See the linker
script for comments about the new <tt>.init</tt><em>N</em> sections
(which one to use, etc.).

The advantage of this method is that you can insert any initialization
code you want (just remember that this is very early startup -- no
stack and no <tt>__zero_reg__</tt> yet), and no program memory space
is wasted if this feature is not used.

There should be no need to modify linker scripts anymore, except for
some very special cases.  It is best to leave <tt>__stack</tt> at its
default value (end of internal SRAM -- faster, and required on some
devices like ATmega161 because of errata), and add
<tt>-Wl,-Tdata,0x801100</tt> to start the data section above the
stack.

There's also a way to modify the startup sequence from within C:

\code
void my_init (void) __attribute__ ((naked)) \
    __attribute__ ((section (".init1")));

void
my_init (void)
{
      /* your init code here; C or inline asm */
}
\endcode

<small>Back to \ref faq_index.
</small>

<b>\subsection faq_use_bv What is all this _BV() stuff about?
</b>

When performing low-level output work, which is a very central point
in microcontroller programming, it is quite common that a particular
bit needs to be set or cleared in some IO register.  While the device
documentation provides mnemonic names for the various bits in the IO
registers, and the \ref avr_io reflect these names in definitions for
numerical constants, a way is needed to convert a bit number (usually
within a byte register) into a byte value that can be assigned
directly to the register.  However, sometimes the direct bit numbers
are needed as well (e. g. in an <tt>sbi()</tt> call), so the
definitions cannot usefully be made as byte values in the first place.

So in order to access a particular bit number as a byte value, use the
<tt>_BV()</tt> macro.  Of course, the implementation of this macro is
just the usual bit shift (which is done by the compiler anyway, thus
doesn't impose any run-time penalty), so the following applies:

\code
_BV(3) => 1 << 3 => 0x08
\endcode

However, using the macro often makes the program better readable.

"BV" stands for "bit value", in case someone might ask you. :-)

<b>Example:</b> clock timer 2 with full IO clock
(<tt>CS2</tt><em>x</em> = 0b001), toggle OC2 output on compare match
(<tt>COM2</tt><em>x</em> = 0b01), and clear timer on compare match
(<tt>CTC2</tt> = 1).  Make OC2 (<tt>PD7</tt>) an output.

\code
	TCCR2 = _BV(COM20)|_BV(CTC2)|_BV(CS20);
	DDRD = _BV(PD7);
\endcode

<small>Back to \ref faq_index.
</small>

<b>\subsection faq_cplusplus Can I use C++ on the AVR?
</b>

Basically yes, C++ is supported (assuming your compiler has been
configured and compiled to support it, of course).  Source files
ending in \c .cc, \c .cpp or \c .C will automatically cause the
compiler frontend to invoke the C++ compiler.  Alternatively, the C++
compiler could be explicitly called by the name \c avr-c++.

However, there's currently no support for \c libstdc++, the standard
support library needed for a complete C++ implementation.  This
imposes a number of restrictions on the C++ programs that can be
compiled.  Among them are:

- Obviously, none of the C++ related standard functions, classes,
  and template classes are available.

- The operators \c new and \c delete are not implemented, attempting
  to use them will cause the linker to complain about undefined
  external references.  (This could perhaps be fixed.)

- Some of the supplied include files are not C++ safe, i. e. they need
  to be wrapped into \code extern "C" { . . . } \endcode
  (This could certainly be fixed, too.)

- Exceptions are not supported.  Since exceptions are enabled by
  default in the C++ frontend, they explicitly need to be turned
  off using \c -fno-exceptions in the compiler options.  Failing
  this, the linker will complain about an undefined external
  reference to \c __gxx_personality_sj0.

Constructors and destructors \e are supported though, including global
ones.

When programming C++ in space- and runtime-sensitive environments like
microcontrollers, extra care should be taken to avoid unwanted side
effects of the C++ calling conventions like implied copy constructors
that could be called upon function invocation etc.  These things could
easily add up into a considerable amount of time and program memory
wasted.  Thus, casual inspection of the generated assembler code
(using the \c -S compiler option) seems to be warranted.

<small>Back to \ref faq_index.
</small>

<b>\subsection faq_16bitio Why do some 16-bit timer registers sometimes get trashed?
</b>

Some of the timer-related 16-bit IO registers use a temporary register
(called TEMP in the Atmel datasheet) to guarantee an atomic access to
the register despite the fact that two separate 8-bit IO transfers are
required to actually move the data.  Typically, this includes access
to the current timer/counter value register (<tt>TCNT</tt><em>n</em>),
the input capture register (<tt>ICR</tt><em>n</em>), and write access
to the output compare registers (<tt>OCR</tt><em>nM</em>).  Refer to
the actual datasheet for each device's set of registers that involves
the TEMP register.

When accessing one of the registers that use TEMP from the main
application, and possibly any other one from within an interrupt
routine, care must be taken that no access from within an interrupt
context could clobber the TEMP register data of an in-progress
transaction that has just started elsewhere.

To protect interrupt routines against other interrupt routines, it's
usually best to use the SIGNAL() macro when declaring the interrupt
function, and to ensure that interrupts are still disabled when
accessing those 16-bit timer registers.

Within the main program, access to those registers could be
encapsulated in calls to the cli() and sei() macros.  If the status of
the global interrupt flag before accessing one of those registers is
uncertain, something like the following example code can be used.

\code
uint16_t
read_timer1(void)
{
	uint8_t sreg;
	uint16_t val;

	sreg = SREG;
	cli();
	val = TCNT1;
	SREG = sreg;

	return val;
}
\endcode

<small>Back to \ref faq_index.
</small>

\subsection faq_asmconst How do I use a #define'd constant in an asm statement?

So you tried this:

\code
asm volatile("sbi 0x18,0x07;");
\endcode

Which works. When you do the same thing but replace the address of the port
by its macro name, like this:

\code
asm volatile("sbi PORTB,0x07;");
\endcode

you get a compilation error: <tt>"Error: constant value required"</tt>.

\c PORTB is a precompiler definition included in the processor specific file
included in \c avr/io.h. As you may know, the precompiler will not touch
strings and <tt>PORTB</tt>, instead of <tt>0x18</tt>, gets passed to the
assembler. One way to avoid this problem is:

\code
asm volatile("sbi %0, 0x07" : "I" (PORTB):);
\endcode

\note \c avr/io.h already provides a sbi() macro definition, which can be used
in C programs.

<small>Back to \ref faq_index.
</small>
*/
