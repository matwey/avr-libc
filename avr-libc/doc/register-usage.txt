This looks like a FAQ, so here is how gcc currently uses AVR
registers, this information is necessary to write assembler
subroutines that call (or are called from) C code.

This information applies to avr-gcc as of 2000-11-18 CVS.

 - Data types:
	"char" is 8 bits, "int" is 16 bits, "long" is 32 bits,
	"long long" is 64 bits, "float" is 32 bits (this is the
	only supported floating point format), pointers are 16 bits
	(function pointers are word addresses, to allow addressing
	the whole 128K program memory space on ATmega103).
	There is a -mint8 option to make "int" 8 bits, but that
	is not supported by avr-libc and violates C standards
	("int" MUST be at least 16 bits).  It may be removed.

 - Call-used registers (r18-r27, r30-r31):
	May be allocated by gcc for local data.
	You MAY use them freely in assembler subroutines.
	Calling C subroutines can clobber any of them -
	the caller is responsible for saving and restoring.

 - Call-saved registers (r2-r17, r28-r29):
	May be allocated by gcc for local data.
	Calling C subroutines leaves them unchanged.
	Assembler subroutines are responsible for saving
	and restoring these registers, if changed.
	r29:r28 (Y pointer) is used as a frame pointer
	(points to local data on stack) if necessary.

 - Fixed registers (r0, r1):
	Never allocated by gcc for local data, but often
	used for fixed purposes:
	r0 - temporary register, can be clobbered by any
	C code (except interrupt handlers which save it),
	MAY be used to remember something for a while
	within one piece of assembler code
	r1 - assumed to be always zero in any C code,
	MAY be used to remember something for a while
	within one piece of assembler code, but MUST
	then be cleared after use ("clr r1").  This
	includes any use of the [f]mul[s[u]] instructions,
	which return their result in r1:r0.
	Interrupt handlers save and clear r1 on entry,
	and restore r1 on exit (in case it was non-zero).

 - Function call conventions:
	Arguments - allocated left to right, r25 to r8.
	All arguments are aligned to start in even-numbered
	registers (odd-sized arguments, including "char", have
	one free register above them).  This allows making better
	use of the "movw" instruction on the enhanced core.
	(Warning: there was no such alignment before 2000-07-01,
	including the old patches for gcc-2.95.2.  Check your old
	assembler subroutines, and adjust them accordingly.)
	If too many, the ones that don't fit are passed on
	the stack (XXX more details - but this should be
	avoided, because it results in less efficient code).
	Return values: 8-bit in r24 (not r25!), 16-bit in r25:r24,
	up to 32 bits in r22-r25, up to 64 bits in r18-r25
	(XXX check how larger objects are returned).
	8-bit return values are zero/sign-extended to
	16 bits by the caller ("unsigned char" is more
	efficient than "signed char" - just "clr r25").
	Arguments to functions with variable argument lists
	(printf etc.) are all passed on stack, and "char"
	is extended to "int".

