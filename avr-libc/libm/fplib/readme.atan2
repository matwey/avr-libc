/* ----------------------------------------------------------------------------------------------

  atan2.S

  Author:   Reiner Patommel
  
atan2.S uses CORDIC, an algorithm which was developed in 1956 by Jack Volder.
CORDIC can be used to calculate trigonometric, hyperbolic and linear
functions and is until today implemented in most pocket calculators.
The algorithm makes only use of simple integer arithmetic.

The CORDIC equations in vectoring mode for trigonometric functions are:
Xi+1 = Xi - Si * (Yi * 1 / 2^i)
Yi+1 = Yi + Si * (Xi * 1 / 2^i)
Zi+1 = Zi - Si *  atan(1 / 2^i)
where Si = +1 if Yi < 0 else Si = -1
The rotation angles are limited to -PI/2 and PI/2 i.e.
-90 degrees ... +90 degrees

For the calculation of atan2(x,y) we need a small pre-calculated table of
angles or radians with the values Tn = atan(1/2^i).
We rotate the vector(Xo,Yo) in steps to the x-axis i.e. we drive Y to 0 and
accumulate the rotated angles or radians in Z.  The direction of the rotation 
will be positive or negative depending on the sign of Y after the previous
rotation and the rotation angle will decrease from step to step. (The first
step is 45 degrees, the last step is 0.002036 degrees for n = 15).

After n rotations the variables will have the following values:
Yn	= ideally 0
Xn	= c*sqrt(Xo^2+Yo^2)			(magnitude of the vector)
Zn	= Zo+atan(Yo/Xo)			(accumulated rotation angles or radians)

c, the cordic gain, is the product Pn of sqrt(1+2^(-2i)) and amounts to
approx. 1.64676 for n = 15.

In order to represent X, Y and Z as integers we introduce a scaling factor Q
which is chosen as follows:
1.	We normalize Xo and Yo (starting values) to be less than or equal to 1*Q and 
	set Zo = 0 i.e. Xomax = 1*Q, Yomax = 1*Q, Zo = 0.
2.	With Xo = 1*Q and Yo = 1*Q, Xn will be Xnmax = Q*c*sqrt(2) = 2.329*Q
3.	In order to boost accuracy we only cover the rotation angles between 0 and PI/2
	i.e. X and Z are always > 0 and therefore can be unsigned.
	(We do the quadrant correction afterwards based on the initial signs of x and y)
4.	If X is an unsigned int, Xnmax = 65536, and Q = 65536/2.329 = 28140.
	i.e.
	Xnmax = 65536					--> unsigned int
	Ynmax = +/- 28140				--> signed int
	Znmax = PI/2 * 28140 = 44202	--> unsigned int
	The systematic error is 90/44202 = 0.002036 degrees or 0.0000355 rad.
	

Below is atan2 and atan in C:

/* ---------------------------------------------------------------------*/
/* atan2.c, atan.c														*/
/* ---------------------------------------------------------------------*/
/* INCLUDES																*/
/* ---------------------------------------------------------------------*/
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

/* ---------------------------------------------------------------------*/
/* DEFINITIONS															*/
/* ---------------------------------------------------------------------*/
#define T			16
#define Q	28140
#define SCALED(X)	((int)((X) * Q))

/* ---------------------------------------------------------------------*/
/* PROTOTYPES															*/
/* ---------------------------------------------------------------------*/
void make_table(void);
float my_atan(float x);
float my_atan2(float x, float y);

/* ---------------------------------------------------------------------*/
/* GLOBAL VARIABLES														*/
/* ---------------------------------------------------------------------*/
unsigned short int Rad[T];
float ag_const;
float res;
float x, y, z;

/* ---------------------------------------------------------------------*/
int main(int argc,char *argv[])
{
	printf("\nQ=%d\n",Q);
	make_table();

	for (y = -10; y <= 10 ; y += 0.1)
	{
		res = my_atan(y);
		printf("\nmy_atan(%9.8f) = %9.8f atan(%9.8f) = %9.8f err = %9.8f",
			y , res, y, atan(y), res - atan(y));
	}

	x =  1;  y = 1;
	res = my_atan2(x,y);
	printf("\nmy_atan2(%9.8f,%9.8f) = %9.8f err = %9.8f",
		x, y, res, res - atan2(x, y));
	return 0;
}

/* ---------------------------------------------------------------------*/
void make_table(void)
{
	unsigned char i;

	ag_const = 1;
	for (i = 0; i < T-1; i++)
	{
		Rad[i] = Q * atan(1.0 / pow(2.0, i));
		printf("%d\n", Rad[i]);
		ag_const *= sqrt(1.0 + pow(2.0, -2.0 * i));
	}
	printf("ag const %12.15f\n", ag_const);
}

/* ---------------------------------------------------------------------*/
float my_atan(float x)
{
	return (my_atan2(1.0, (float)x));
}

/* ---------------------------------------------------------------------*/
float my_atan2(float x, float y)
{
	unsigned char i;
	unsigned short int X;
	short int Y;
	unsigned short int Z = 0;
	unsigned short int tmp;
	float x1, y1;

	x1 = fabs(x);
	y1 = fabs(y);

	if (y1 == 0)
		if (x < 0) return (M_PI);
		else return 0;
	if (x1 >= y1)
	{
		y1 /= x1; x1 = 1;
	}
	else
	{
		x1 /= y1; y1 = 1;
	}
	X = SCALED(x1);
	Y = SCALED(y1);
	for (i = 0; i < T-1; i++)
	{
		tmp = X >> i;
		printf("\nx = %3.2f y = %3.2f X = %5d\tY = %5d\tZ = %5d\tT = %5d",
			x, y, X, Y, Z, tmp);
		if (Y < 0)
		{
			X -= Y >> i;
			Y += tmp;
			Z -= Rad[i];
		}
		else
		{
			X += Y >> i;
			Y -= tmp;
			Z += Rad[i];
		}
		printf("\nx = %3.2f y = %3.2f X = %5d\tY = %5d\tZ = %5d\tT = %5d",
			x, y, X, Y, Z, tmp);
	}
	if (x > 0)
	{
		if (y > 0) return( (float)Z / (float)Q);
		else return(-((float)Z / (float)Q));
	}
	else
	{
		if (y > 0) return((float)( (SCALED(M_PI) - Z) / (float)Q));
		else return(-((float)((SCALED(M_PI) - Z) / (float)Q)));
	}
}

/* ---------------------------------------------------------------------*/
